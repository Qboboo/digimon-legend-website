#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Êï∞Á†ÅÂÖΩ‰º†ËØ¥ÁΩëÁ´ô - JSONÊï∞ÊçÆËøÅÁßªÂà∞SQLÊï∞ÊçÆÂ∫ìËÑöÊú¨
ÊîØÊåÅMySQLÂíåPostgreSQL
"""

import json
import os
import sys
from pathlib import Path
from datetime import datetime
import logging

# Êï∞ÊçÆÂ∫ìÈ©±Âä®ÈÄâÊã©
try:
    import pymysql
    MYSQL_AVAILABLE = True
except ImportError:
    MYSQL_AVAILABLE = False

try:
    import psycopg2
    import psycopg2.extras
    POSTGRESQL_AVAILABLE = True
except ImportError:
    POSTGRESQL_AVAILABLE = False

# ÈÖçÁΩÆÊó•Âøó
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('migration.log', encoding='utf-8'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

class DatabaseMigrator:
    def __init__(self, db_type='mysql', **db_config):
        self.db_type = db_type.lower()
        self.db_config = db_config
        self.connection = None
        self.cursor = None
        
        # È°πÁõÆË∑ØÂæÑ
        self.project_root = Path(__file__).parent.parent
        self.data_path = self.project_root / 'frontend' / 'js' / 'data'
        
    def connect(self):
        """ËøûÊé•Êï∞ÊçÆÂ∫ì"""
        try:
            if self.db_type == 'mysql':
                if not MYSQL_AVAILABLE:
                    raise ImportError("ËØ∑ÂÆâË£Öpymysql: pip install pymysql")
                
                self.connection = pymysql.connect(
                    host=self.db_config.get('host', 'localhost'),
                    user=self.db_config.get('user', 'root'),
                    password=self.db_config.get('password', ''),
                    database=self.db_config.get('database', 'digimon_legend'),
                    charset='utf8mb4',
                    autocommit=False
                )
                
            elif self.db_type == 'postgresql':
                if not POSTGRESQL_AVAILABLE:
                    raise ImportError("ËØ∑ÂÆâË£Öpsycopg2: pip install psycopg2-binary")
                
                self.connection = psycopg2.connect(
                    host=self.db_config.get('host', 'localhost'),
                    user=self.db_config.get('user', 'postgres'),
                    password=self.db_config.get('password', ''),
                    database=self.db_config.get('database', 'digimon_legend'),
                    port=self.db_config.get('port', 5432)
                )
                
            else:
                raise ValueError(f"‰∏çÊîØÊåÅÁöÑÊï∞ÊçÆÂ∫ìÁ±ªÂûã: {self.db_type}")
                
            self.cursor = self.connection.cursor()
            logger.info(f"‚úÖ ÊàêÂäüËøûÊé•Âà∞ {self.db_type.upper()} Êï∞ÊçÆÂ∫ì")
            
        except Exception as e:
            logger.error(f"‚ùå Êï∞ÊçÆÂ∫ìËøûÊé•Â§±Ë¥•: {e}")
            raise
    
    def create_tables(self):
        """ÂàõÂª∫Êï∞ÊçÆÂ∫ìË°®"""
        logger.info("üî® ÂºÄÂßãÂàõÂª∫Êï∞ÊçÆÂ∫ìË°®...")
        
        if self.db_type == 'mysql':
            tables = self._get_mysql_tables()
        else:
            tables = self._get_postgresql_tables()
        
        for table_name, create_sql in tables.items():
            try:
                self.cursor.execute(f"DROP TABLE IF EXISTS {table_name}")
                self.cursor.execute(create_sql)
                logger.info(f"‚úÖ ÂàõÂª∫Ë°® {table_name}")
            except Exception as e:
                logger.error(f"‚ùå ÂàõÂª∫Ë°® {table_name} Â§±Ë¥•: {e}")
                raise
        
        self.connection.commit()
        logger.info("üéâ ÊâÄÊúâË°®ÂàõÂª∫ÂÆåÊàê")
    
    def _get_mysql_tables(self):
        """MySQLË°®ÁªìÊûÑ"""
        return {
            'digimons': """
                CREATE TABLE digimons (
                    id VARCHAR(50) PRIMARY KEY,
                    name VARCHAR(100) NOT NULL,
                    image VARCHAR(500),
                    positioning VARCHAR(50),
                    type VARCHAR(10),
                    armor VARCHAR(20),
                    fit VARCHAR(10),
                    egg VARCHAR(10),
                    time VARCHAR(20),
                    skills JSON,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
            """,
            
            'evolutions': """
                CREATE TABLE evolutions (
                    id VARCHAR(50) PRIMARY KEY,
                    card_data JSON,
                    main_data JSON,
                    stages JSON,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
            """,
            
            'equipment': """
                CREATE TABLE equipment (
                    id INT AUTO_INCREMENT PRIMARY KEY,
                    dungeon_id VARCHAR(50) NOT NULL,
                    dungeon_name VARCHAR(100) NOT NULL,
                    dungeon_image VARCHAR(500),
                    equipment_sets JSON,
                    loose_items JSON,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    UNIQUE KEY unique_dungeon (dungeon_id)
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
            """,
            
            'items': """
                CREATE TABLE items (
                    id VARCHAR(50) PRIMARY KEY,
                    name VARCHAR(100) NOT NULL,
                    category VARCHAR(50),
                    image VARCHAR(500),
                    description TEXT,
                    acquisition_method TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
            """,
            
            'synthesis_recipes': """
                CREATE TABLE synthesis_recipes (
                    id VARCHAR(50) PRIMARY KEY,
                    target_item_id VARCHAR(50) NOT NULL,
                    materials JSON,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
            """,
            
            'guides': """
                CREATE TABLE guides (
                    id INT AUTO_INCREMENT PRIMARY KEY,
                    original_id INT,
                    title VARCHAR(200) NOT NULL,
                    slug VARCHAR(200) UNIQUE NOT NULL,
                    category VARCHAR(50) NOT NULL,
                    difficulty VARCHAR(50),
                    summary TEXT,
                    content LONGTEXT,
                    content_type VARCHAR(20) DEFAULT 'html',
                    status VARCHAR(20) DEFAULT 'draft',
                    update_date DATE,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
            """,
            
            'changelogs': """
                CREATE TABLE changelogs (
                    id INT AUTO_INCREMENT PRIMARY KEY,
                    version VARCHAR(20) UNIQUE NOT NULL,
                    date DATE NOT NULL,
                    changes JSON,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
            """
        }
    
    def _get_postgresql_tables(self):
        """PostgreSQLË°®ÁªìÊûÑ"""
        return {
            'digimons': """
                CREATE TABLE digimons (
                    id VARCHAR(50) PRIMARY KEY,
                    name VARCHAR(100) NOT NULL,
                    image VARCHAR(500),
                    positioning VARCHAR(50),
                    type VARCHAR(10),
                    armor VARCHAR(20),
                    fit VARCHAR(10),
                    egg VARCHAR(10),
                    time VARCHAR(20),
                    skills JSONB,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """,
            
            'evolutions': """
                CREATE TABLE evolutions (
                    id VARCHAR(50) PRIMARY KEY,
                    card_data JSONB,
                    main_data JSONB,
                    stages JSONB,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """,
            
            'equipment': """
                CREATE TABLE equipment (
                    id SERIAL PRIMARY KEY,
                    dungeon_id VARCHAR(50) NOT NULL UNIQUE,
                    dungeon_name VARCHAR(100) NOT NULL,
                    dungeon_image VARCHAR(500),
                    equipment_sets JSONB,
                    loose_items JSONB,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """,
            
            'items': """
                CREATE TABLE items (
                    id VARCHAR(50) PRIMARY KEY,
                    name VARCHAR(100) NOT NULL,
                    category VARCHAR(50),
                    image VARCHAR(500),
                    description TEXT,
                    acquisition_method TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """,
            
            'synthesis_recipes': """
                CREATE TABLE synthesis_recipes (
                    id VARCHAR(50) PRIMARY KEY,
                    target_item_id VARCHAR(50) NOT NULL,
                    materials JSONB,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """,
            
            'guides': """
                CREATE TABLE guides (
                    id SERIAL PRIMARY KEY,
                    original_id INTEGER,
                    title VARCHAR(200) NOT NULL,
                    slug VARCHAR(200) UNIQUE NOT NULL,
                    category VARCHAR(50) NOT NULL,
                    difficulty VARCHAR(50),
                    summary TEXT,
                    content TEXT,
                    content_type VARCHAR(20) DEFAULT 'html',
                    status VARCHAR(20) DEFAULT 'draft',
                    update_date DATE,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """,
            
            'changelogs': """
                CREATE TABLE changelogs (
                    id SERIAL PRIMARY KEY,
                    version VARCHAR(20) UNIQUE NOT NULL,
                    date DATE NOT NULL,
                    changes JSONB,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """
        }

    def load_json_data(self, filename):
        """Âä†ËΩΩJSONÊï∞ÊçÆÊñá‰ª∂"""
        file_path = self.data_path / filename
        if not file_path.exists():
            logger.warning(f"‚ö†Ô∏è  Êñá‰ª∂‰∏çÂ≠òÂú®: {file_path}")
            return None

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            logger.info(f"üìñ ÊàêÂäüÂä†ËΩΩ {filename}, Êï∞ÊçÆÈáè: {len(data) if isinstance(data, (list, dict)) else 'N/A'}")
            return data
        except Exception as e:
            logger.error(f"‚ùå Âä†ËΩΩ {filename} Â§±Ë¥•: {e}")
            return None

    def migrate_digimons(self):
        """ËøÅÁßªÊï∞Á†ÅÂÖΩÊï∞ÊçÆ"""
        logger.info("üîÑ ÂºÄÂßãËøÅÁßªÊï∞Á†ÅÂÖΩÊï∞ÊçÆ...")
        data = self.load_json_data('digimon.json')
        if not data:
            return

        for item in data:
            try:
                # Â§ÑÁêÜÊäÄËÉΩÊï∞ÊçÆ
                skills_json = json.dumps(item.get('skills', []), ensure_ascii=False)

                sql = """
                    INSERT INTO digimons (id, name, image, positioning, type, armor, fit, egg, time, skills)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                """

                values = (
                    item.get('id'),
                    item.get('name'),
                    item.get('image'),
                    item.get('positioning'),
                    item.get('Type'),  # Ê≥®ÊÑèÂéüÊï∞ÊçÆ‰∏≠ÊòØÂ§ßÂÜôÁöÑType
                    item.get('armor'),
                    item.get('fit'),
                    item.get('egg'),
                    item.get('time'),
                    skills_json
                )

                self.cursor.execute(sql, values)

            except Exception as e:
                logger.error(f"‚ùå ÊèíÂÖ•Êï∞Á†ÅÂÖΩÊï∞ÊçÆÂ§±Ë¥•: {e}, Êï∞ÊçÆ: {item.get('id', 'unknown')}")

        self.connection.commit()
        logger.info(f"‚úÖ Êï∞Á†ÅÂÖΩÊï∞ÊçÆËøÅÁßªÂÆåÊàêÔºåÂÖ± {len(data)} Êù°")

    def migrate_evolutions(self):
        """ËøÅÁßªËøõÂåñÊï∞ÊçÆ"""
        logger.info("üîÑ ÂºÄÂßãËøÅÁßªËøõÂåñÊï∞ÊçÆ...")
        data = self.load_json_data('evolutions.json')
        if not data:
            return

        for evo_id, evo_data in data.items():
            try:
                card_data = json.dumps(evo_data.get('card', {}), ensure_ascii=False)
                main_data = json.dumps(evo_data.get('main', {}), ensure_ascii=False)
                stages_data = json.dumps(evo_data.get('stages', []), ensure_ascii=False)

                sql = """
                    INSERT INTO evolutions (id, card_data, main_data, stages)
                    VALUES (%s, %s, %s, %s)
                """

                values = (evo_id, card_data, main_data, stages_data)
                self.cursor.execute(sql, values)

            except Exception as e:
                logger.error(f"‚ùå ÊèíÂÖ•ËøõÂåñÊï∞ÊçÆÂ§±Ë¥•: {e}, ID: {evo_id}")

        self.connection.commit()
        logger.info(f"‚úÖ ËøõÂåñÊï∞ÊçÆËøÅÁßªÂÆåÊàêÔºåÂÖ± {len(data)} Êù°")

    def migrate_equipment(self):
        """ËøÅÁßªË£ÖÂ§áÊï∞ÊçÆ"""
        logger.info("üîÑ ÂºÄÂßãËøÅÁßªË£ÖÂ§áÊï∞ÊçÆ...")
        data = self.load_json_data('equipment.json')
        if not data:
            return

        for item in data:
            try:
                equipment_sets = json.dumps(item.get('equipmentSets', []), ensure_ascii=False)
                loose_items = json.dumps(item.get('looseItems', []), ensure_ascii=False)

                sql = """
                    INSERT INTO equipment (dungeon_id, dungeon_name, dungeon_image, equipment_sets, loose_items)
                    VALUES (%s, %s, %s, %s, %s)
                """

                values = (
                    item.get('dungeonId'),
                    item.get('dungeonName'),
                    item.get('dungeonImage'),
                    equipment_sets,
                    loose_items
                )

                self.cursor.execute(sql, values)

            except Exception as e:
                logger.error(f"‚ùå ÊèíÂÖ•Ë£ÖÂ§áÊï∞ÊçÆÂ§±Ë¥•: {e}, ÂâØÊú¨ID: {item.get('dungeonId', 'unknown')}")

        self.connection.commit()
        logger.info(f"‚úÖ Ë£ÖÂ§áÊï∞ÊçÆËøÅÁßªÂÆåÊàêÔºåÂÖ± {len(data)} Êù°")

    def migrate_items(self):
        """ËøÅÁßªÁâ©ÂìÅÊï∞ÊçÆ"""
        logger.info("üîÑ ÂºÄÂßãËøÅÁßªÁâ©ÂìÅÊï∞ÊçÆ...")
        data = self.load_json_data('items.json')
        if not data:
            return

        for item in data:
            try:
                sql = """
                    INSERT INTO items (id, name, category, image, description, acquisition_method)
                    VALUES (%s, %s, %s, %s, %s, %s)
                """

                values = (
                    item.get('id'),
                    item.get('name'),
                    item.get('category'),
                    item.get('image'),
                    item.get('description'),
                    item.get('acquisitionMethod', item.get('acquisition_method'))  # ÂÖºÂÆπ‰∏§ÁßçÂ≠óÊÆµÂêç
                )

                self.cursor.execute(sql, values)

            except Exception as e:
                logger.error(f"‚ùå ÊèíÂÖ•Áâ©ÂìÅÊï∞ÊçÆÂ§±Ë¥•: {e}, ID: {item.get('id', 'unknown')}")

        self.connection.commit()
        logger.info(f"‚úÖ Áâ©ÂìÅÊï∞ÊçÆËøÅÁßªÂÆåÊàêÔºåÂÖ± {len(data)} Êù°")

    def migrate_synthesis(self):
        """ËøÅÁßªÂêàÊàêÈÖçÊñπÊï∞ÊçÆ"""
        logger.info("üîÑ ÂºÄÂßãËøÅÁßªÂêàÊàêÈÖçÊñπÊï∞ÊçÆ...")
        data = self.load_json_data('synthesis.json')
        if not data:
            return

        for item in data:
            try:
                materials = json.dumps(item.get('materials', []), ensure_ascii=False)

                sql = """
                    INSERT INTO synthesis_recipes (id, target_item_id, materials)
                    VALUES (%s, %s, %s)
                """

                values = (
                    item.get('id'),
                    item.get('targetItemId'),
                    materials
                )

                self.cursor.execute(sql, values)

            except Exception as e:
                logger.error(f"‚ùå ÊèíÂÖ•ÂêàÊàêÈÖçÊñπÊï∞ÊçÆÂ§±Ë¥•: {e}, ID: {item.get('id', 'unknown')}")

        self.connection.commit()
        logger.info(f"‚úÖ ÂêàÊàêÈÖçÊñπÊï∞ÊçÆËøÅÁßªÂÆåÊàêÔºåÂÖ± {len(data)} Êù°")

    def migrate_guides(self):
        """ËøÅÁßªÊîªÁï•ÊåáÂçóÊï∞ÊçÆ"""
        logger.info("üîÑ ÂºÄÂßãËøÅÁßªÊîªÁï•ÊåáÂçóÊï∞ÊçÆ...")
        data = self.load_json_data('guides.json')
        if not data:
            return

        for item in data:
            try:
                # Â§ÑÁêÜÊó•ÊúüÂ≠óÊÆµ
                update_date = None
                if item.get('updateDate'):
                    try:
                        update_date = datetime.strptime(item['updateDate'], '%Y-%m-%d').date()
                    except:
                        pass

                sql = """
                    INSERT INTO guides (original_id, title, slug, category, difficulty, summary,
                                      content, content_type, status, update_date)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                """

                values = (
                    item.get('id'),
                    item.get('title'),
                    item.get('slug'),
                    item.get('category'),
                    item.get('difficulty'),
                    item.get('summary'),
                    item.get('content'),
                    item.get('contentType', 'html'),
                    item.get('status', 'draft'),
                    update_date
                )

                self.cursor.execute(sql, values)

            except Exception as e:
                logger.error(f"‚ùå ÊèíÂÖ•ÊîªÁï•Êï∞ÊçÆÂ§±Ë¥•: {e}, ID: {item.get('id', 'unknown')}")

        self.connection.commit()
        logger.info(f"‚úÖ ÊîªÁï•ÊåáÂçóÊï∞ÊçÆËøÅÁßªÂÆåÊàêÔºåÂÖ± {len(data)} Êù°")

    def migrate_changelogs(self):
        """ËøÅÁßªÊõ¥Êñ∞Êó•ÂøóÊï∞ÊçÆ"""
        logger.info("üîÑ ÂºÄÂßãËøÅÁßªÊõ¥Êñ∞Êó•ÂøóÊï∞ÊçÆ...")
        data = self.load_json_data('changelog.json')
        if not data:
            return

        for item in data:
            try:
                # Â§ÑÁêÜÊó•Êúü
                log_date = None
                if item.get('date'):
                    try:
                        log_date = datetime.strptime(item['date'], '%Y-%m-%d').date()
                    except:
                        pass

                changes = json.dumps(item.get('changes', []), ensure_ascii=False)

                sql = """
                    INSERT INTO changelogs (version, date, changes)
                    VALUES (%s, %s, %s)
                """

                values = (
                    item.get('version'),
                    log_date,
                    changes
                )

                self.cursor.execute(sql, values)

            except Exception as e:
                logger.error(f"‚ùå ÊèíÂÖ•Êõ¥Êñ∞Êó•ÂøóÊï∞ÊçÆÂ§±Ë¥•: {e}, ÁâàÊú¨: {item.get('version', 'unknown')}")

        self.connection.commit()
        logger.info(f"‚úÖ Êõ¥Êñ∞Êó•ÂøóÊï∞ÊçÆËøÅÁßªÂÆåÊàêÔºåÂÖ± {len(data)} Êù°")

    def run_migration(self):
        """ÊâßË°åÂÆåÊï¥ÁöÑÊï∞ÊçÆËøÅÁßª"""
        logger.info("üöÄ ÂºÄÂßãÊï∞ÊçÆËøÅÁßª...")
        start_time = datetime.now()

        try:
            # ËøûÊé•Êï∞ÊçÆÂ∫ì
            self.connect()

            # ÂàõÂª∫Ë°®
            self.create_tables()

            # ËøÅÁßªÂêÑÁ±ªÊï∞ÊçÆ
            self.migrate_digimons()
            self.migrate_evolutions()
            self.migrate_equipment()
            self.migrate_items()
            self.migrate_synthesis()
            self.migrate_guides()
            self.migrate_changelogs()

            end_time = datetime.now()
            duration = end_time - start_time
            logger.info(f"üéâ Êï∞ÊçÆËøÅÁßªÂÆåÊàêÔºÅËÄóÊó∂: {duration}")

        except Exception as e:
            logger.error(f"üí• Êï∞ÊçÆËøÅÁßªÂ§±Ë¥•: {e}")
            if self.connection:
                self.connection.rollback()
            raise
        finally:
            self.close()

    def close(self):
        """ÂÖ≥Èó≠Êï∞ÊçÆÂ∫ìËøûÊé•"""
        if self.cursor:
            self.cursor.close()
        if self.connection:
            self.connection.close()
        logger.info("üì¥ Êï∞ÊçÆÂ∫ìËøûÊé•Â∑≤ÂÖ≥Èó≠")


def main():
    """‰∏ªÂáΩÊï∞"""
    print("üî• Êï∞Á†ÅÂÖΩ‰º†ËØ¥ÁΩëÁ´ô - Êï∞ÊçÆËøÅÁßªÂ∑•ÂÖ∑")
    print("=" * 50)

    # Êï∞ÊçÆÂ∫ìÈÖçÁΩÆ
    db_configs = {
        'mysql': {
            'host': 'localhost',
            'user': 'root',
            'password': '',  # ËØ∑‰øÆÊîπ‰∏∫ÊÇ®ÁöÑÂØÜÁ†Å
            'database': 'digimon_legend'
        },
        'postgresql': {
            'host': 'localhost',
            'user': 'postgres',
            'password': '',  # ËØ∑‰øÆÊîπ‰∏∫ÊÇ®ÁöÑÂØÜÁ†Å
            'database': 'digimon_legend',
            'port': 5432
        }
    }

    # ÈÄâÊã©Êï∞ÊçÆÂ∫ìÁ±ªÂûã
    print("ËØ∑ÈÄâÊã©Êï∞ÊçÆÂ∫ìÁ±ªÂûã:")
    print("1. MySQL")
    print("2. PostgreSQL")

    choice = input("ËØ∑ËæìÂÖ•ÈÄâÊã© (1 Êàñ 2): ").strip()

    if choice == '1':
        db_type = 'mysql'
        if not MYSQL_AVAILABLE:
            print("‚ùå ËØ∑ÂÖàÂÆâË£ÖMySQLÈ©±Âä®: pip install pymysql")
            return
    elif choice == '2':
        db_type = 'postgresql'
        if not POSTGRESQL_AVAILABLE:
            print("‚ùå ËØ∑ÂÖàÂÆâË£ÖPostgreSQLÈ©±Âä®: pip install psycopg2-binary")
            return
    else:
        print("‚ùå Êó†ÊïàÈÄâÊã©")
        return

    # Ëé∑ÂèñÊï∞ÊçÆÂ∫ìÈÖçÁΩÆ
    config = db_configs[db_type].copy()

    print(f"\nÂΩìÂâçÈÖçÁΩÆ ({db_type.upper()}):")
    for key, value in config.items():
        if key == 'password':
            display_value = '*' * len(value) if value else '(Á©∫)'
        else:
            display_value = value
        print(f"  {key}: {display_value}")

    # Á°ÆËÆ§ÊòØÂê¶‰øÆÊîπÈÖçÁΩÆ
    modify = input("\nÊòØÂê¶ÈúÄË¶Å‰øÆÊîπÈÖçÁΩÆ? (y/N): ").strip().lower()
    if modify == 'y':
        for key in config.keys():
            if key == 'password':
                new_value = input(f"ËØ∑ËæìÂÖ• {key} (ÂΩìÂâç: {'*' * len(config[key]) if config[key] else '(Á©∫)'}): ").strip()
            else:
                new_value = input(f"ËØ∑ËæìÂÖ• {key} (ÂΩìÂâç: {config[key]}): ").strip()

            if new_value:
                if key == 'port':
                    config[key] = int(new_value)
                else:
                    config[key] = new_value

    # Á°ÆËÆ§ÂºÄÂßãËøÅÁßª
    print(f"\nÂáÜÂ§áËøÅÁßªÊï∞ÊçÆÂà∞ {db_type.upper()} Êï∞ÊçÆÂ∫ì...")
    confirm = input("Á°ÆËÆ§ÂºÄÂßãËøÅÁßª? (y/N): ").strip().lower()
    if confirm != 'y':
        print("‚ùå ËøÅÁßªÂ∑≤ÂèñÊ∂à")
        return

    # ÊâßË°åËøÅÁßª
    migrator = DatabaseMigrator(db_type, **config)
    migrator.run_migration()


if __name__ == '__main__':
    main()
